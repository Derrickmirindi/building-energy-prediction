<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Energy Prediction – Residual 1D‑CNN</title>

    <!-- Load TensorFlow.js (Layers API, needed for loadLayersModel) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Times New Roman', serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            padding: 40px 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.3em; margin-bottom: 6px; font-weight: bold; }
        .header p  { font-size: 1.0em; opacity: 0.96; }

        .content { padding: 32px 38px 38px 38px; }

        .info-section {
            background: #f8f9fa;
            border-left: 5px solid #667eea;
            padding: 16px 18px;
            margin-bottom: 26px;
            border-radius: 8px;
        }
        .info-section h3 {
            color: #667eea;
            margin-bottom: 6px;
            font-size: 1.12em;
        }
        .info-section p { color: #555; line-height: 1.6; font-size: 0.95em; }

        .form-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 24px;
        }
        .form-group { display: flex; flex-direction: column; }
        .form-group label {
            font-weight: bold;
            color: #333;
            margin-bottom: 6px;
            font-size: 0.93em;
        }
        .form-group input {
            padding: 9px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.96em;
            font-family: 'Times New Roman', serif;
            transition: border-color 0.25s;
        }
        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 4px rgba(102,126,234,0.35);
        }
        .form-group small {
            color: #888;
            font-size: 0.8em;
            margin-top: 4px;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 24px;
        }
        button {
            padding: 12px 22px;
            font-size: 0.98em;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.25s;
            font-family: 'Times New Roman', serif;
        }
        .btn-predict {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
        }
        .btn-predict:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(102,126,234,0.4);
        }
        .btn-clear {
            background: #e0e0e0;
            color: #333333;
        }
        .btn-clear:hover { background: #d0d0d0; }

        .status {
            padding: 11px 14px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
            font-size: 0.9em;
        }
        .status.loading { background: #fff3cd; color: #856404; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error   { background: #f8d7da; color: #721c24; }
        .hidden { display: none; }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 24px;
            padding-top: 22px;
            border-top: 2px solid #e0e0e0;
        }
        .result-card {
            padding: 20px 16px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        .result-card.heating {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        }
        .result-card.cooling {
            background: linear-gradient(135deg, #d0e8f2 0%, #a8d8ea 100%);
        }
        .result-card h3 { color: #333; margin-bottom: 10px; font-size: 1.18em; }
        .result-value   { font-size: 2.1em; font-weight: bold; color: #1f3a93; margin: 8px 0; }
        .result-unit    { font-size: 0.95em; color: #444; }

        .model-info {
            background: #f0f4f8;
            padding: 18px 20px;
            border-radius: 8px;
            margin-top: 28px;
            border: 2px solid #667eea;
        }
        .model-info h4 { color: #667eea; margin-bottom: 8px; font-size: 1.05em; }
        .model-info p  { color: #555; margin-bottom: 6px; font-size: 0.9em; line-height: 1.5; }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 8px;
        }
        .metric {
            background: #ffffff;
            padding: 9px 10px;
            border-radius: 6px;
            text-align: center;
            border-left: 4px solid #667eea;
        }
        .metric-label { color: #666; font-size: 0.8em; margin-bottom: 3px; }
        .metric-value { font-size: 1.1em; font-weight: bold; color: #334296; }

        @media (max-width: 800px) {
            .form-container { grid-template-columns: 1fr; }
            .results-container { grid-template-columns: 1fr; }
            .button-group { grid-template-columns: 1fr; }
            .content { padding: 24px 18px 30px 18px; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Building Energy Prediction</h1>
                    <p>Residual 1D-CNN - Browser Inference</p>
    </div>

    <div class="content">
        <div class="info-section">
            <h3>Model description</h3>
                            <p><strong>Back-end architecture:</strong> Residual 1D-CNN trained on the UCI energy efficiency dataset (Athens, Greece).</p>
            <p><strong>Front‑end:</strong> this page loads the exact converted Keras model (<code>model.json</code>) via TensorFlow.js and applies the same standardization and inverse‑transform as in the Python script, so predictions match the original CNN up to numerical precision.</p>
        </div>

        <form id="predictionForm">
            <div class="form-container">
                <div class="form-group">
                    <label for="relativeCompactness">Relative Compactness</label>
                    <input type="number" id="relativeCompactness" step="0.01" min="0" required>
                    <small>0.62 – 0.98</small>
                </div>
                <div class="form-group">
                    <label for="surfaceArea">Surface Area (m²)</label>
                    <input type="number" id="surfaceArea" step="0.1" min="0" required>
                    <small>≈ 514.5 – 808.0</small>
                </div>
                <div class="form-group">
                    <label for="wallArea">Wall Area (m²)</label>
                    <input type="number" id="wallArea" step="0.1" min="0" required>
                    <small>≈ 245.0 – 416.5</small>
                </div>
                <div class="form-group">
                    <label for="roofArea">Roof Area (m²)</label>
                    <input type="number" id="roofArea" step="0.1" min="0" required>
                    <small>≈ 110.25 – 220.50</small>
                </div>
                <div class="form-group">
                    <label for="overallHeight">Overall Height (m)</label>
                    <input type="number" id="overallHeight" step="0.1" min="0" required>
                    <small>3.5 or 7.0 in dataset</small>
                </div>
                <div class="form-group">
                    <label for="orientation">Orientation (code)</label>
                    <input type="number" id="orientation" step="1" min="2" max="5" required>
                    <small>2, 3, 4, 5 (cardinal orientations)</small>
                </div>
                <div class="form-group">
                    <label for="glazingArea">Glazing Area (ratio)</label>
                    <input type="number" id="glazingArea" step="0.01" min="0" max="0.4" required>
                    <small>0.0 – 0.4 façade glazed</small>
                </div>
                <div class="form-group">
                    <label for="glazingDistribution">Glazing Area Distribution</label>
                    <input type="number" id="glazingDistribution" step="1" min="0" max="5" required>
                    <small>0 = none, 1–5 = patterns</small>
                </div>
            </div>

            <div class="button-group">
                <button type="submit" class="btn-predict">Predict loads</button>
                <button type="reset" class="btn-clear">Clear</button>
            </div>
        </form>

        <div id="status" class="status hidden"></div>

        <div id="resultsContainer" class="results-container hidden">
            <div class="result-card heating">
                <h3>Heating Load</h3>
                <div class="result-value" id="heatingResult">0.00</div>
                <div class="result-unit">kWh/m²</div>
            </div>
            <div class="result-card cooling">
                <h3>Cooling Load</h3>
                <div class="result-value" id="coolingResult">0.00</div>
                <div class="result-unit">kWh/m²</div>
            </div>
        </div>

        <div class="model-info">
            <h4>Reproducibility notes</h4>
            <p><strong>Scaling:</strong> inputs and outputs are standardized with the same means and standard deviations as in the Python script (scikit‑learn <code>StandardScaler</code>), then inverse‑transformed to physical units for display.</p>
            <p><strong>Workflow:</strong> train and validate in Python, save <code>best_cnn_energy_model.h5</code>, convert to TF.js, and serve <code>model.json</code> with this HTML page for interactive use.</p>
        </div>
    </div>
</div>

<script>
    // 1) URL to the converted TF.js model (update this to your hosting location)
    // e.g. if model.json is in the same folder as this HTML, use './model.json'
                const MODEL_URL = './model.json';
    let cnnModel = null;

    // 2) Scaling parameters – REPLACE with the exact values from scaler_X.mean_, scaler_X.scale_,
    const X_MEAN = [
            22.698703, 49.961839, 492.748137, 4.904251, 50.276970, 298.547788, 12.169583, 3.103697
    ];
    const X_STD = [
            4.301230, 11.807317, 290.087135, 2.906698, 29.026695, 117.430135, 6.821211, 1.710163
    ];

    const Y_MEAN = [
            169.880058, 134.955756
    ];
    const Y_STD = [
            31.607900, 44.547197
    ];

    function updateStatus(message, type) {
        const el = document.getElementById('status');
        el.textContent = message;
        el.className = 'status ' + type;
        el.classList.remove('hidden');
    }

    async function loadModel() {
        try {
            updateStatus('Loading CNN model...', 'loading');
            cnnModel = await tf.loadLayersModel(MODEL_URL);
            // Warm‑up call (optional)
            const dummy = tf.zeros([1, 8, 1]);
            const out = cnnModel.predict(dummy);
            // Model has two outputs (heating and cooling); dispose warm‑up tensors
            if (Array.isArray(out)) {
                out.forEach(t => t.dispose());
            } else {
                out.dispose();
            }
            dummy.dispose();
            updateStatus('Model loaded. Ready for predictions.', 'success');
        } catch (err) {
            console.error(err);
            updateStatus('Error loading model: ' + err.message, 'error');
        }
    }

    function getInputs() {
        return [
            parseFloat(document.getElementById('relativeCompactness').value),
            parseFloat(document.getElementById('surfaceArea').value),
            parseFloat(document.getElementById('wallArea').value),
            parseFloat(document.getElementById('roofArea').value),
            parseFloat(document.getElementById('overallHeight').value),
            parseFloat(document.getElementById('orientation').value),
            parseFloat(document.getElementById('glazingArea').value),
            parseFloat(document.getElementById('glazingDistribution').value)
        ];
    }

    function standardize(values, meanArr, stdArr) {
        return values.map((v, i) => (v - meanArr[i]) / stdArr[i]);
    }

    function inverseStandardize(values, meanArr, stdArr) {
        return values.map((z, i) => z * stdArr[i] + meanArr[i]);
    }

    document.getElementById('predictionForm').addEventListener('submit', async function (e) {
        e.preventDefault();

        try {
            if (!cnnModel) {
                updateStatus('Model not loaded yet. Please wait a moment and try again.', 'error');
                return;
            }

            const vals = getInputs();
            if (vals.some(v => Number.isNaN(v))) {
                updateStatus('Please enter valid numeric values for all fields.', 'error');
                return;
            }

            updateStatus('Running CNN inference...', 'loading');

            // Standardize inputs
            const xStd = standardize(vals, X_MEAN, X_STD);

            // Create tensor of shape [1, 8, 1] as in Python (batch, sequence_len, channels)
            const xTensor = tf.tensor3d(
                [xStd.map(v => [v])],  // wrap each feature in [v] to make channel dimension
                [1, 8, 1]
            );

            // Predict – model has two outputs (heating, cooling), each of shape [1, 1]
            const pred = cnnModel.predict(xTensor);

            let heatingStd, coolingStd;
            if (Array.isArray(pred)) {
                const hArr = await pred[0].data();
                const cArr = await pred[1].data();
                heatingStd = hArr[0];
                coolingStd = cArr[0];
                pred.forEach(t => t.dispose());
            } else {
                // If you exported as a single 2‑unit output layer instead of two heads
                const arr = await pred.data();
                heatingStd = arr[0];
                coolingStd = arr[1];
                pred.dispose();
            }
            xTensor.dispose();

            // Inverse standardization to kWh/m²
            const [heating, cooling] = inverseStandardize(
                [heatingStd, coolingStd],
                Y_MEAN,
                Y_STD
            );

            // Clip to dataset‑plausible ranges
            const heatingClipped = Math.min(Math.max(heating, 6.0), 45.0);
            const coolingClipped = Math.min(Math.max(cooling, 11.0), 48.0);

            document.getElementById('heatingResult').textContent = heatingClipped.toFixed(2);
            document.getElementById('coolingResult').textContent = coolingClipped.toFixed(2);
            document.getElementById('resultsContainer').classList.remove('hidden');

            updateStatus(
                `Prediction complete | Heating: ${heatingClipped.toFixed(2)} kWh/m² | Cooling: ${coolingClipped.toFixed(2)} kWh/m²`,
                'success'
            );
        } catch (err) {
            console.error(err);
            updateStatus('Prediction error: ' + err.message, 'error');
        }
    });

    window.addEventListener('load', loadModel);
</script>
</body>
</html>
