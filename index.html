<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Energy Prediction – MLP</title>

    <!-- Load TensorFlow.js (Layers API, needed for loadLayersModel) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <!-- Optional: WASM backend for broader compatibility fallback -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.22.0/dist/tf-backend-wasm.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Times New Roman', serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            padding: 40px 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.3em; margin-bottom: 6px; font-weight: bold; }
        .header p  { font-size: 1.0em; opacity: 0.96; }

        .content { padding: 32px 38px 38px 38px; }

        .info-section {
            background: #f8f9fa;
            border-left: 5px solid #667eea;
            padding: 16px 18px;
            margin-bottom: 26px;
            border-radius: 8px;
        }
        .info-section h3 {
            color: #667eea;
            margin-bottom: 6px;
            font-size: 1.12em;
        }
        .info-section p { color: #555; line-height: 1.6; font-size: 0.95em; }

        .form-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 24px;
        }
        .form-group { display: flex; flex-direction: column; }
        .form-group label {
            font-weight: bold;
            color: #333;
            margin-bottom: 6px;
            font-size: 0.93em;
        }
        .form-group input {
            padding: 9px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.96em;
            font-family: 'Times New Roman', serif;
            transition: border-color 0.25s;
        }
        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 4px rgba(102,126,234,0.35);
        }
        .form-group small {
            color: #888;
            font-size: 0.8em;
            margin-top: 4px;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 24px;
        }
        button {
            padding: 12px 22px;
            font-size: 0.98em;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.25s;
            font-family: 'Times New Roman', serif;
        }
        .btn-predict {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
        }
        .btn-predict:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(102,126,234,0.4);
        }
        .btn-clear {
            background: #e0e0e0;
            color: #333333;
        }
        .btn-clear:hover { background: #d0d0d0; }

        .status {
            padding: 11px 14px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
            font-size: 0.9em;
        }
        .status.loading { background: #fff3cd; color: #856404; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error   { background: #f8d7da; color: #721c24; }
        .hidden { display: none; }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 24px;
            padding-top: 22px;
            border-top: 2px solid #e0e0e0;
        }
        .result-card {
            padding: 20px 16px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        .result-card.heating {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        }
        .result-card.cooling {
            background: linear-gradient(135deg, #d0e8f2 0%, #a8d8ea 100%);
        }
        .result-card h3 { color: #333; margin-bottom: 10px; font-size: 1.18em; }
        .result-value   { font-size: 2.1em; font-weight: bold; color: #1f3a93; margin: 8px 0; }
        .result-unit    { font-size: 0.95em; color: #444; }

        .model-info {
            background: #f0f4f8;
            padding: 18px 20px;
            border-radius: 8px;
            margin-top: 28px;
            border: 2px solid #667eea;
        }
        .model-info h4 { color: #667eea; margin-bottom: 8px; font-size: 1.05em; }
        .model-info p  { color: #555; margin-bottom: 6px; font-size: 0.9em; line-height: 1.5; }

        @media (max-width: 800px) {
            .form-container { grid-template-columns: 1fr; }
            .results-container { grid-template-columns: 1fr; }
            .button-group { grid-template-columns: 1fr; }
            .content { padding: 24px 18px 30px 18px; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Building Energy Prediction</h1>
        <p>MLP - Browser Inference</p>
    </div>

    <div class="content">
        <div class="info-section">
            <h3>Model description</h3>
            <p><strong>Back-end architecture:</strong> Multi-Layer Perceptron (MLP) trained on the UCI energy efficiency dataset (Athens, Greece).</p>
            <p><strong>Front‑end:</strong> this page loads the converted Keras model (<code>model.json</code>) via TensorFlow.js and applies the same standardization and inverse‑transform as in the Python script using <code>scaler_params.json</code>, so predictions match the original training pipeline.</p>
        </div>

        <form id="predictionForm">
            <div class="form-container">
                <div class="form-group">
                    <label for="relativeCompactness">Relative Compactness</label>
                    <input type="number" id="relativeCompactness" step="0.01" min="0" value="0.79" required>
                    <small>0.62 – 0.98</small>
                </div>
                <div class="form-group">
                    <label for="surfaceArea">Surface Area (m²)</label>
                    <input type="number" id="surfaceArea" step="0.1" min="0" value="637.0" required>
                    <small>≈ 514.5 – 808.0</small>
                </div>
                <div class="form-group">
                    <label for="wallArea">Wall Area (m²)</label>
                    <input type="number" id="wallArea" step="0.1" min="0" value="318.5" required>
                    <small>≈ 245.0 – 416.5</small>
                </div>
                <div class="form-group">
                    <label for="roofArea">Roof Area (m²)</label>
                    <input type="number" id="roofArea" step="0.1" min="0" value="147.0" required>
                    <small>≈ 110.25 – 220.50</small>
                </div>
                <div class="form-group">
                    <label for="overallHeight">Overall Height (m)</label>
                    <input type="number" id="overallHeight" step="0.1" min="0" value="7.0" required>
                    <small>3.5 or 7.0 in dataset</small>
                </div>
                <div class="form-group">
                    <label for="orientation">Orientation (code)</label>
                    <input type="number" id="orientation" step="1" min="2" max="5" value="3" required>
                    <small>2, 3, 4, 5 (cardinal orientations)</small>
                </div>
                <div class="form-group">
                    <label for="glazingArea">Glazing Area (ratio)</label>
                    <input type="number" id="glazingArea" step="0.01" min="0" max="0.4" value="0.25" required>
                    <small>0.0 – 0.4 façade glazed</small>
                </div>
                <div class="form-group">
                    <label for="glazingDistribution">Glazing Area Distribution</label>
                    <input type="number" id="glazingDistribution" step="1" min="0" max="5" value="3" required>
                    <small>0 = none, 1–5 = patterns</small>
                </div>
            </div>

            <div class="button-group">
                <button type="submit" class="btn-predict">Predict loads</button>
                <button type="reset" class="btn-clear">Clear</button>
            </div>
        </form>

        <div id="status" class="status hidden"></div>

        <div id="resultsContainer" class="results-container hidden">
            <div class="result-card heating">
                <h3>Heating Load</h3>
                <div class="result-value" id="heatingResult">0.00</div>
                <div class="result-unit">kWh/m²</div>
            </div>
            <div class="result-card cooling">
                <h3>Cooling Load</h3>
                <div class="result-value" id="coolingResult">0.00</div>
                <div class="result-unit">kWh/m²</div>
            </div>
        </div>

        <div class="model-info">
            <h4>Reproducibility notes</h4>
            <p><strong>Scaling:</strong> inputs and outputs are standardized with the same means and standard deviations as in the Python script (scikit‑learn <code>StandardScaler</code>) loaded from <code>scaler_params.json</code>, then inverse‑transformed to physical units for display.</p>
            <p><strong>Workflow:</strong> train and validate in Python, save model, convert to TF.js, and serve <code>model.json</code> with this HTML page for interactive use.</p>
        </div>
    </div>
</div>

<script>
const MODEL_URL = './model.json';
const SCALER_URL = './scaler_params.json';
const INDEXEDDB_KEY = 'indexeddb://building-energy-mlp';
let mlpModel = null;
let scaler = null;
let modelReady = false;
let scalerReady = false;

const statusEl = document.getElementById('status');
const predictBtn = document.querySelector('.btn-predict');
const resultsContainer = document.getElementById('resultsContainer');

function updateStatus(message, type) {
    statusEl.textContent = message;
    statusEl.className = 'status ' + type;
    statusEl.classList.remove('hidden');
}

function maybeEnablePredict() {
    if (modelReady && scalerReady) {
        predictBtn.disabled = false;
        predictBtn.style.opacity = 1.0;
        updateStatus('Model and scaler loaded! Ready for predictions.', 'success');
    }
}

// Disable predict button until model & scaler are loaded
predictBtn.disabled = true;
predictBtn.style.opacity = 0.6;

async function initBackend() {
    try {
        await tf.setBackend('webgl');
        updateStatus('Using WebGL backend for faster inference.', 'loading');
    } catch (e) {
        try {
            if (tf.wasm && tf.wasm.setWasmPaths) {
                tf.wasm.setWasmPaths('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.22.0/dist/');
            }
            await tf.setBackend('wasm');
            updateStatus('WebGL unavailable, using WASM backend.', 'loading');
        } catch (err) {
            await tf.setBackend('cpu');
            updateStatus('Falling back to CPU backend.', 'loading');
        }
    }
    await tf.ready();
}

async function loadScaler() {
    try {
        updateStatus('Loading scaler parameters...', 'loading');
        const resp = await fetch(SCALER_URL);
        scaler = await resp.json();
        scalerReady = true;
        console.log('Scaler loaded:', scaler);
        updateStatus('Scaler parameters loaded.', 'success');
        maybeEnablePredict();
    } catch (err) {
        console.error(err);
        updateStatus('Error loading scaler parameters: ' + err.message, 'error');
    }
}

async function loadModel() {
    try {
        updateStatus('Initializing TensorFlow.js...', 'loading');
        await initBackend();

        // Try to load from IndexedDB cache first (fast on repeat visits)
        updateStatus('Loading model from cache...', 'loading');
        try {
            mlpModel = await tf.loadLayersModel(INDEXEDDB_KEY);
            updateStatus('Model loaded from cache.', 'success');
        } catch (cacheErr) {
            // Fallback: load from URL and then cache it
            updateStatus('Downloading model...', 'loading');
            mlpModel = await tf.loadLayersModel(MODEL_URL, {
                onProgress: (fraction) => {
                    const percent = Math.round(fraction * 100);
                    updateStatus(`Downloading model... ${percent}%`, 'loading');
                },
                strict: false
            });
            try {
                await mlpModel.save(INDEXEDDB_KEY);
                updateStatus('Model cached locally for faster future loads.', 'success');
            } catch (saveErr) {
                console.warn('Failed to cache model:', saveErr);
            }
        }

        // Warm-up prediction (correct input shape for MLP: [batch, 8])
        const dummy = tf.zeros([1, 8]);
        const out = mlpModel.predict(dummy);
        if (Array.isArray(out)) out.forEach(t => t.dispose());
        else out.dispose();
        dummy.dispose();

        console.log('Model loaded successfully');
        console.log('Model inputs:', mlpModel.inputs);
        console.log('Model outputs:', mlpModel.outputs);
        modelReady = true;
        maybeEnablePredict();

    } catch (err) {
        console.error(err);
        updateStatus('Error loading model: ' + err.message, 'error');
    }
}

function getInputs() {
    return [
        parseFloat(document.getElementById('relativeCompactness').value),
        parseFloat(document.getElementById('surfaceArea').value),
        parseFloat(document.getElementById('wallArea').value),
        parseFloat(document.getElementById('roofArea').value),
        parseFloat(document.getElementById('overallHeight').value),
        parseFloat(document.getElementById('orientation').value),
        parseFloat(document.getElementById('glazingArea').value),
        parseFloat(document.getElementById('glazingDistribution').value)
    ];
}

function standardize(values, meanArr, stdArr) {
    return values.map((v, i) => (v - meanArr[i]) / stdArr[i]);
}

function inverseStandardize(values, meanArr, stdArr) {
    return values.map((z, i) => z * stdArr[i] + meanArr[i]);
}

document.getElementById('predictionForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    try {
        if (!mlpModel || !scaler) {
            updateStatus('Please wait for the model and scaler to finish loading.', 'error');
            return;
        }

        const vals = getInputs();
        if (vals.some(v => Number.isNaN(v))) {
            updateStatus('Please enter valid numeric values for all fields.', 'error');
            return;
        }

        updateStatus('Running inference...', 'loading');

        // Standardize inputs
        const xStd = standardize(vals, scaler.X_mean, scaler.X_std);
        const xTensor = tf.tensor2d([xStd], [1, 8]);

        // Make prediction - model returns single tensor with shape [1, 2]
        const pred = mlpModel.predict(xTensor);
        
        // Get output values [heating_scaled, cooling_scaled]
        const output = await pred.data();
        const heatingStd = output[0];
        const coolingStd = output[1];
        
        // Clean up
        xTensor.dispose();
        pred.dispose();

        // Inverse transform to get actual values
        const [heating, cooling] = inverseStandardize([heatingStd, coolingStd], scaler.Y_mean, scaler.Y_std);
        
        // Optional: clip to reasonable ranges
        const heatingClipped = Math.min(Math.max(heating, 6.0), 45.0);
        const coolingClipped = Math.min(Math.max(cooling, 11.0), 48.0);

        document.getElementById('heatingResult').textContent = heatingClipped.toFixed(2);
        document.getElementById('coolingResult').textContent = coolingClipped.toFixed(2);
        resultsContainer.classList.remove('hidden');

        updateStatus(`Prediction complete | Heating: ${heatingClipped.toFixed(2)} kWh/m² | Cooling: ${coolingClipped.toFixed(2)} kWh/m²`, 'success');

    } catch (err) {
        console.error(err);
        updateStatus('Prediction error: ' + err.message, 'error');
    }
});

// Load model & scaler on page load
window.addEventListener('load', () => { loadScaler(); loadModel(); });

// Helper: predict from a simple array of 8 features
async function predictFromArray(inputFeatures) {
    if (!mlpModel || !scaler) {
        throw new Error('Model or scaler not loaded yet');
    }
    if (!Array.isArray(inputFeatures) || inputFeatures.length !== 8) {
        throw new Error('inputFeatures must be an array of 8 numbers');
    }

    const xStd = standardize(inputFeatures, scaler.X_mean, scaler.X_std);
    const xTensor = tf.tensor2d([xStd], [1, 8]);
    const pred = mlpModel.predict(xTensor);
    
    const output = await pred.data();
    const heatingStd = output[0];
    const coolingStd = output[1];
    
    xTensor.dispose();
    pred.dispose();

    const [heating, cooling] = inverseStandardize([heatingStd, coolingStd], scaler.Y_mean, scaler.Y_std);
    const heatingClipped = Math.min(Math.max(heating, 6.0), 45.0);
    const coolingClipped = Math.min(Math.max(cooling, 11.0), 48.0);

    return { heating: heatingClipped, cooling: coolingClipped };
}

// Example usage exposed for convenience
async function examplePrediction() {
    const testInput = [0.79, 637.0, 318.5, 147.0, 7.0, 3.0, 0.25, 3.0];
    const result = await predictFromArray(testInput);
    console.log('Predicted Heating Load:', result.heating.toFixed(2));
    console.log('Predicted Cooling Load:', result.cooling.toFixed(2));
}

window.predictFromArray = predictFromArray;
window.examplePrediction = examplePrediction;
</script>
</body>
</html>