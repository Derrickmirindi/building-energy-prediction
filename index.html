<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Energy Prediction - Developed by Derrick Mirindi</title>

    <!-- Load TensorFlow.js (Layers API, needed for loadLayersModel) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <!-- Optional: WASM backend for broader compatibility fallback -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.22.0/dist/tf-backend-wasm.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Times New Roman', serif;
                        font-size: 20px;
                        text-align: center;
            background: linear-gradient(135deg, #5568ff 0%, #8b3dff 100%);            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 280px;            background: #ffffff;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #5568ff 0%, #8b3dff 100%);            color: #ffffff;
            padding: 25px 20px;
            text-align: center;
        }
        .header h1 { font-size: 1.8em; margin-bottom: 6px; font-weight: bold; }
        .header p  { font-size: 1.0em; opacity: 0.96; }

        .content { padding: 20px 25px 25px 25px; }

        .info-section {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 12px 14px;
            margin-bottom: 18px;
            border-radius: 8px;
        }
        .info-section h3 {
            color: #667eea;
            margin-bottom: 4px;
            font-size: 1.05em;
        }
        .info-section p { color: #555; line-height: 1.5; font-size: 0.9em; }

        .form-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }
        .form-group { display: flex; 58
flex-direction: row    flex-direction: row
                     ; align-items: center; gap: 5px;  justify-content: space-between; }
    .form-group label {
            font-weight: 600;
            color: #333;
            font-size: 1.1em;            flex: 1;
            text-align: left;        }
        .form-group input {
            width: 200px;            padding: 4px 8px;
            border: 2px solid #d0d0d0;
            border-radius: 6px;
            font-size: 1.1em;            font-family: 'Times New Roman', serif;
            transition: border-color 0.25s;
            text-align: center;            background: #fafafa;
        }
        .form-group input:focus {
            outline: none;
            border-color: #5568ff;            box-shadow: 0 0 4px rgba(102,126,234,0.35);
        }
        .form-group small {
            color: #999;
            font-size: 0.9em;            font-style: italic;
            width: 200px;            text-align: center;        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 12px 20px;
            font-size: 1.0em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.25s;
            font-family: 'Times New Roman', serif;
        }
        .btn-predict {
            background: linear-gradient(135deg, #5568ff 0%, #8b3dff 100%);            color: #ffffff;
        }
        .btn-predict:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(102,126,234,0.4);
        }
        .btn-clear {
            background: #e0e0e0;
            color: #333333;
        }
        .btn-clear:hover { background: #d0d0d0; }

        .status {
            padding: 8px 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: 600;
            text-align: center;
            font-size: 0.85em;
        }
        .status.loading { background: #fff3cd; color: #856404; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error   { background: #f8d7da; color: #721c24; }
        .hidden { display: none; }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 1fr;            gap: 12px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }
        .result-card {
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            text-align: center;
        }
        .result-card.heating {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        }
        .result-card.cooling {
            background: linear-gradient(135deg, #d0e8f2 0%, #a8d8ea 100%);
        }
        .result-card h3 { color: #333; margin-bottom: 8px; font-size: 1.0em; font-weight: 600; }
        .result-value   { font-size: 2.0em; font-weight: bold; color: #1f3a93; margin: 5px 0; }
        .result-unit    { font-size: 0.9em; color: #555; }

        .model-info {
            background: #f0f4f8;
            padding: 18px 20px;
            border-radius: 8px;
            margin-top: 28px;
            border: 2px solid #667eea;
        }
        .model-info h4 { color: #667eea; margin-bottom: 8px; font-size: 1.15em; }
        .model-info p  { color: #555; margin-bottom: 6px; font-size: 1.0em; line-height: 1.5; }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 8px;
        }
        .metric {
            background: #ffffff;
            padding: 9px 10px;
            border-radius: 6px;
            text-align: center;
            border-left: 4px solid #667eea;
        }
        .metric-label { color: #666; font-size: 0.9em; margin-bottom: 3px; }
        .metric-value { font-size: 1.2em; font-weight: bold; color: #334296; }

        @media (max-width: 600px) {
            .container { max-width: 95%; margin: 10px auto; }
            .content { padding: 15px 18px 20px 18px; }
            .form-group { flex-direction: column; align-items: stretch; }
            .form-group label { text-align: left; }
            .form-group input { width: 100%; text-align: left; }
            .form-group small { width: 100%; text-align: left; }
        }
    </style>
</head>
<body>
    
    <div class="header">
        <h1>Building Energy Prediction</h1>


    <div class="content">
        <div class="info-section">
            <h3>Convolution Neural Network (CNN) Model</h3>

        <form id="predictionForm">
            <div class="form-container">
                <div class="form-group">
                    <label for="relativeCompactness">Relative Compactness (dimensionless)</label>
                    <input type="number" id="relativeCompactness" step="0.01" min="0" required>
                    <small>0.62 – 0.98</small>
                </div>
                <div class="form-group">
                    <label for="surfaceArea">Surface Area (m²)</label>
                    <input type="number" id="surfaceArea" step="0.01" min="0" required>
                    <small>≈ 514.5 – 808.0</small>
                </div>
                <div class="form-group">
                    <label for="wallArea">Wall Area (m²)</label>
                    <input type="number" id="wallArea" step="0.01" min="0" required>
                    <small>≈ 245.0 – 416.5</small>
                </div>
                <div class="form-group">
                    <label for="roofArea">Roof Area (m²)</label>
                    <input type="number" id="roofArea" step="0.1" min="0" required>
                    <small>≈ 110.25 – 220.50</small>
                </div>
                <div class="form-group">
                    <label for="overallHeight">Overall Height (m)</label>
                    <input type="number" id="overallHeight" step="0.1" min="0" required>
                    <small>3.5 or 7.0 in dataset</small>
                </div>
                <div class="form-group">
                    <label for="orientation">Orientation (dimensionless)</label>
                    <input type="number" id="orientation" step="1" min="2" max="5" required>
                    <small>2, 3, 4, 5 (cardinal orientations)</small>
                </div>
                <div class="form-group">
                    <label for="glazingArea">Glazing Area (dimensionless)</label>
                    <input type="number" id="glazingArea" step="0.01" min="0" max="0.4" required>
                    <small>0.0 – 0.4 façade glazed</small>
                </div>
                <div class="form-group">
                    <label for="glazingDistribution">Glazing Area Distribution (dimensionless)</label>
                    <input type="number" id="glazingDistribution" step="1" min="0" max="5" required>
                    <small>0 = none, 1–5 = patterns</small>
                </div>
            </div>

            <div class="button-group">
                <button type="submit" class="btn-predict">Predict loads</button>
                <button type="reset" class="btn-clear">Clear</button>
            </div>
        </form>

        <div id="status" class="status hidden"></div>

        <div id="resultsContainer" class="results-container hidden">
            <div class="result-card heating">
                <h3>Heating Load</h3>
                <div class="result-value" id="heatingResult">0.00</div>
                <div class="result-unit">kWh/m²</div>
            </div>
            <div class="result-card cooling">
                <h3>Cooling Load</h3>
                <div class="result-value" id="coolingResult">0.00</div>
                <div class="result-unit">kWh/m²</div>
            </div>
        </div>


    </div>
</div>

<script>
const MODEL_URL = './model.json';
const INDEXEDDB_KEY = 'indexeddb://building-energy-mlp';
let cnnModel = null;
let scaler = null;
let modelReady = false;
let scalerReady = false;

const statusEl = document.getElementById('status');
const predictBtn = document.querySelector('.btn-predict');
const resultsContainer = document.getElementById('resultsContainer');

function updateStatus(message, type) {
    statusEl.textContent = message;
    statusEl.className = 'status ' + type;
    statusEl.classList.remove('hidden');
}

function maybeEnablePredict() {
    if (modelReady && scalerReady) {
        predictBtn.disabled = false;
        predictBtn.style.opacity = 1.0;
        updateStatus('Model and scaler loaded! Ready for predictions.', 'success');
    }
}

// Disable predict button until model & scaler are loaded
predictBtn.disabled = true;
predictBtn.style.opacity = 0.6;

async function initBackend() {
    try {
        await tf.setBackend('webgl');
        updateStatus('Using WebGL backend for faster inference.', 'loading');
    } catch (e) {
        try {
            if (tf.wasm && tf.wasm.setWasmPaths) {
                tf.wasm.setWasmPaths('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.22.0/dist/');
            }
            await tf.setBackend('wasm');
            updateStatus('WebGL unavailable, using WASM backend.', 'loading');
        } catch (err) {
            await tf.setBackend('cpu');
            updateStatus('Falling back to CPU backend.', 'loading');
        }
    }
    await tf.ready();
}

async function loadScaler() {
    try {
        updateStatus('Loading scaler parameters...', 'loading');
        const resp = await fetch('./scaler_params.json');
        scaler = await resp.json();
        scalerReady = true;
        updateStatus('Scaler parameters loaded.', 'success');
        maybeEnablePredict();
    } catch (err) {
        console.error(err);
        updateStatus('Error loading scaler parameters: ' + err.message, 'error');
    }
}

async function loadModel() {
    try {
        updateStatus('Initializing TensorFlow.js...', 'loading');
        await initBackend();

        // Try to load from IndexedDB cache first (fast on repeat visits)
        updateStatus('Loading model from cache...', 'loading');
        try {
            cnnModel = await tf.loadLayersModel(INDEXEDDB_KEY);
            updateStatus('Model loaded from cache.', 'success');
        } catch (cacheErr) {
            // Fallback: load from URL and then cache it
            updateStatus('Downloading model...', 'loading');
            cnnModel = await tf.loadLayersModel(MODEL_URL, {
                onProgress: (fraction) => {
                    const percent = Math.round(fraction * 100);
                    updateStatus(`Downloading model... ${percent}%`, 'loading');
                },
                strict: false
            });
            try {
                await cnnModel.save(INDEXEDDB_KEY);
                updateStatus('Model cached locally for faster future loads.', 'success');
            } catch (saveErr) {
                console.warn('Failed to cache model:', saveErr);
            }
        }

        // Warm-up prediction (correct input shape for MLP: [batch, 8])
        const dummy = tf.zeros([1, 8]);
        const out = cnnModel.predict(dummy);
        if (Array.isArray(out)) out.forEach(t => t.dispose());
        else out.dispose();
        dummy.dispose();

        modelReady = true;
        maybeEnablePredict();

    } catch (err) {
        console.error(err);
        updateStatus('Error loading model: ' + err.message, 'error');
    }
}

function getInputs() {
    return [
        parseFloat(document.getElementById('relativeCompactness').value),
        parseFloat(document.getElementById('surfaceArea').value),
        parseFloat(document.getElementById('wallArea').value),
        parseFloat(document.getElementById('roofArea').value),
        parseFloat(document.getElementById('overallHeight').value),
        parseFloat(document.getElementById('orientation').value),
        parseFloat(document.getElementById('glazingArea').value),
        parseFloat(document.getElementById('glazingDistribution').value)
    ];
}

function standardize(values, meanArr, stdArr) {
    return values.map((v, i) => (v - meanArr[i]) / stdArr[i]);
}

function inverseStandardize(values, meanArr, stdArr) {
    return values.map((z, i) => z * stdArr[i] + meanArr[i]);
}

document.getElementById('predictionForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    try {
        if (!cnnModel || !scaler) {
            updateStatus('Please wait for the model and scaler to finish loading.', 'error');
            return;
        }

        const vals = getInputs();
        if (vals.some(v => Number.isNaN(v))) {
            updateStatus('Please enter valid numeric values for all fields.', 'error');
            return;
        }

        updateStatus('Running inference...', 'loading');

        const xStd = standardize(vals, scaler.X_mean, scaler.X_std);
        const xTensor = tf.tensor2d([xStd], [1, 8]);

        const pred = cnnModel.predict(xTensor);
        let heatingStd, coolingStd;

        if (Array.isArray(pred)) {
            const hArr = await pred[0].data();
            const cArr = await pred[1].data();
            heatingStd = hArr[0];
            coolingStd = cArr[0];
            pred.forEach(t => t.dispose());
        } else {
            const arr = await pred.data();
            heatingStd = arr[0];
            coolingStd = arr[1];
            pred.dispose();
        }

        xTensor.dispose();

        const [heating, cooling] = inverseStandardize([heatingStd, coolingStd], scaler.Y_mean, scaler.Y_std);
        const heatingClipped = Math.min(Math.max(heating, 6.0), 45.0);
        const coolingClipped = Math.min(Math.max(cooling, 11.0), 48.0);

        document.getElementById('heatingResult').textContent = heatingClipped.toFixed(2);
        document.getElementById('coolingResult').textContent = coolingClipped.toFixed(2);
        resultsContainer.classList.remove('hidden');

        updateStatus(`Prediction complete | Heating: ${heatingClipped.toFixed(2)} kWh/m² | Cooling: ${coolingClipped.toFixed(2)} kWh/m²`, 'success');

    } catch (err) {
        console.error(err);
        updateStatus('Prediction error: ' + err.message, 'error');
    }
});

// Load model & scaler on page load
window.addEventListener('load', () => { loadScaler(); loadModel(); });
</script>

            <div style="text-align: center; padding: 20px 15px; border-top: 2px solid #e0e0e0; margin-top: 20px;">
        <p style="font-size: 0.85em; color: #555; line-height: 1.6;">
            This web application uses a trained Convolutional Neural Network (CNN)<br>
            to predict building heating and cooling loads<br>
            from eight design parameters.<br>
            It provides fast estimates of the loads in kWh/m² and<br>
            serves as a decision support tool for building<br>
            and HVAC design.
        </p>
        <p style="font-size: 0.9em; color: ##5568ff; font-weight: 600; margin-top: 15px;">
            Developed by Derrick Mirindi
        </p>
    </div>
</body>
</html>










